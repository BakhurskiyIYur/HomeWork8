# Домашнее задание №8 (Тема "Настройка PostgreSQL")

Описание/Пошаговая инструкция выполнения домашнего задания:

* Развернуть виртуальную машину любым удобным способом
* Поставить на неё PostgreSQL 15 любым способом
  > <img src="pic/2_1.JPG" align="center" />
* Настроить кластер PostgreSQL 15 на максимальную производительность не обращая внимание на возможные проблемы с надежностью в случае аварийной перезагрузки виртуальной машины
  
<br>__*Перед тем, как настраивать кластер PostgreSQL на максимальную производительность, проверим утилитой pgbench, сколько выдает TPS:*__
  > <img src="pic/3_2.JPG" align="center" />
<br>__*-c 50 Количество моделируемых клиентов, т. е. количество одновременных сеансов базы данных.*__
<br>__*-j 2 Количество рабочих потоков, клиенты распределяются максимально равномерно по доступным потокам. Значение по умолчанию - 1.*__
<br>__*-P 60 Отображает отчет о ходе выполнения каждые 60 секунд.*__
<br>__*-T 600 Выполняет тест в течение этого количества секунд.*__
<br>__*-U postgres postgres Имя пользователя, к которому необходимо подключиться.*__  
 
<br>__*После этого начинаю настраивать кластер PostgreSQL на максимальную производительность, изменяя значения конфигурационных параметров.*__ 

<br>__*1 Cделать создание точек восстановления раз в 59 минут, чтобы на время тестирования процесс создания точек восстановления не пересекался с создаваемой нагрузкой. Ранее значение параметра было 5 минут.*__
> <img src="pic/3_checkpoint_timeout.JPG" align="center" />

<br>__*2 Параметр "wal_buffers", первоначально значение 4 МБ, зададим 16 МБ.*__
 > <img src="pic/3_wal_buffers.JPG" align="center" />

<br>__*3 Параметр "max_wal_size", первоначально значение 1 ГБ, зададим 5 ГБ.*__
> <img src="pic/3_max_wal_size.JPG" align="center" />

<br>__*4 Параметр "min_wal_size", первоначально значение 80 МБ, зададим 1 ГБ.*__
> <img src="pic/3_min_wal_size.JPG" align="center" />

<br>__*5 Параметр "work_mem", первоначально значение 4 МБ, зададим 16 МБ.*__
> <img src="pic/3_work_mem.JPG" align="center" />

<br>__*6 Параметр "shared_buffers", первоначально значение 128 МБ, зададим 1 ГБ.*__
> <img src="pic/3_shared_buffers.JPG" align="center" />

<br>__*7 Параметр "maintenance_work_mem", первоначально значение 64 МБ, зададим 2 ГБ.*__
> <img src="pic/3_maintenance_work_mem.JPG" align="center" />

<br>__*8 Параметр "Max_connections", первоначально значение 100, зададим 5.*__
> <img src="pic/3_max_connections.JPG" align="center" />

<br>__*9 Параметр "effective_cache_size", первоначально значение 4 ГБ, зададим 15 ГБ.*__
> <img src="pic/3_effective_cache_size.JPG" align="center" />

<br>__*Перезапускаю (pg_reload_conf), чтобы изменения применились и снова утилитой pgbench выполню нагрузку.*__
<br>__*В самом начале до настройки кластера TPS был равен 278.77 и число выполненных транзакций - 167300.*__
<br>__*После настройки кластера TPS равен 301.19 и число выполненных транзакций - 180721.*__ 
> <img src="pic/3_3.JPG" align="center" />

<br>__* Параметр "synchronous_commit", первоначально значение "on", зададим "off"*__
> <img src="pic/4_2_1.JPG" align="center" />

> <img src="pic/4_2_2.JPG" align="center" />

* 4 Нагрузить кластер через утилиту через утилиту pgbench (https://postgrespro.ru/docs/postgrespro/14/pgbench)
sudo apt-get install postgresql-contrib
sudo su postgres
pgbench -i postgres -- Требуется для вызова режима инициализации.

pgbench -c8 -j 2 -P 60 -T 600 -U postgres postgres
-c8 Количество моделируемых клиентов, т. е. количество одновременных сеансов базы данных
-j 2 Количество рабочих потоков в pgbench. Использование нескольких потоков может быть полезно на многопроцессорных машинах. Клиенты распределяются максимально равномерно по доступным потокам. Значение по умолчанию — 1.
-P 60  Показывайте отчет о ходе выполнения каждые секунды
-T 600  Выполняйте тест в течение этого количества секунд, а не фиксированного количества транзакций на клиента.
-U postgres postgres  Имя пользователя, к которому необходимо подключиться

 <br>__*Запись журнала происходит в одном из двух режимов:*__
  <br>__*- синхронном — при фиксации транзакции продолжение работы невозможно до тех пор, пока все журнальные записи об этой транзакции не окажутся на диске;*__
  <br>__*- асинхронном — транзакция завершается немедленно, а журнал записывается в фоновом режиме.*__
  <br>__*При синхронной записи гарантируется долговечность (буква D в аббревиатуре ACID) — если транзакция зафиксирована, то все ее журнальные записи уже на диске и не будут потеряны. Обратная сторона состоит в том, что синхронная запись увеличивает время отклика (команда COMMIT не возвращает управление до окончания синхронизации) и уменьшает производительность системы. Асинхронная запись эффективнее синхронной — фиксация изменений не ждет записи. Однако надежность уменьшается: зафиксированные данные могут пропасть в случае сбоя, если между фиксацией и сбоем прошло менее 3 × wal_writer_delay времени (что при настройке по умолчанию составляет чуть больше полсекунды).*__
  
* 5 Написать какого значения tps удалось достичь, показать какие параметры в какие значения устанавливали и почему


